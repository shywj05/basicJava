package f_OOP2;

public class OOP2_01 {
	public static void main(String[] args) {
		/*
		1. 상속(is a)
			- 기존의  클래스를 재사용하여 새로운 클래스를 작성한다
			- 적은양의 코드로 새로운 클래스를 작성할 수 있다
			- 새로 작성하고자 하는 클래스 뒤에 상속받고자 하는 클래스의 이름을
			  extends 와 함께 써주기만 하면 된다
			  class child extends parent{ //우선순위가 parent가 더 높다 크기는 child가 더 클 수 밖에 없지
			  
			  }
			  
			- 상속해주는 클래스를 조상클래스, 상속받는 클래스를 자손클래스라고 한다
			  : 조상클래스 -> 부모클래스, 상위클래스, 기반클래스
			  : 자식클래스 -> 자식클래스, 하위클래스, 파생클래스
			  
			- 멤버만 상속된다
			  : 자손클래스의 멤버의 갯수는 조상클래스의 항상 같거나 많다
		
		2. 포함(has a)
			- 상속이외 클래스 재사용하는 방법
			- 한 클래스의 멤버 변수로 다른 클래스를 선언하는 방법
		
			- toString()
			  : 인스턴스의 정보를 반환할 목적으로 만들어 졌다
			  
		3. 단일상속
			- 자바에서는 단일상속(두개 이상 불가능)만 가능하다
			 class TVCR extends TV, VCR{ //두개 받는 건 불가능
			 	
			 }
			
			- Tv와 VCR에 같은 메서드가 존재할 대 어떤 것을 상속받을 지 알 수 없다
			- 메서드의 명을 바꾼다면 기존의 사용중이던 모든 곳을 수정해야 된다
			- 클래스 간의 관계가 보다 명확해지고 더욱 신뢰할 수 있도록 해준다
	
		4. Object 클래스
			- 모든 클래스의 상속계층도의 제일 위에 위치하는 조상 클래스이다
			- 다른 클래스로부터 상속받지 않는 클래스는 자동적으로 Object클래스를 상속받는다
			  class Tv{                      class Tv extends Object{     
			  				=>
			  }                              }
			- toString(), equals()와 같은 메서드를 따로 정의하지 않고 사용하는 것은 Object클래스에 정의돈 것이기 때문
			
		5. 오버라이드(override)
			- 조상 클래스로부터 상속받은 메서드의 내용을 수정하는 것 //재정의한 것
			- 오버라이드의 조건(선언부가 일치해야한다)
			  : 상속받는 메서드의 이름이 같이야 한다
			  : 매개변수의 갯수와 타입이 같아야 한다
			  : 반환타입도 같아야 한다
			  
			- 조상 클래스의 메서드르 자손 클래스에서 오버라이드 할때
			  접근제어자를 조상클래스의 메서드보다 좁은 범위를 선택할 수 없다
			  예외는 조상클래스의 메서드보다 많이 선언할 수 없다
			  인스턴스 메서드를 클래서 메서드로 변경할 수 없다
		  
		 6. super.
		    - 조상클래스의 멤버와 자손클래스의 멤버가 중복정의 되어 서로 구분해야 되는 경우 사용
		    - 자손클래스의 멤버에서만 사용 가능
		    - 조상의 멤버와 자신의 멤버를 구분하는데 사용된다는 점을 제외하고 this.과 동일하다
		    - 클래스 메서드에는 사용할 수 없다 인스턴스 메서드에만 사용가능!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			
		 7. super() 
		 	- this()와 마찬가지로 super()도 생성자 호출이다
		 	- this()는 같은 클래스에서 다른 생성자 호출시에 사용
		 	- super()자손클래스의 생성자에서 부모 클래스의 생성자를 호출할 때 사용
		 	- 둘다 생성자 호출 할 때는 생성자의 가장 첫 줄에 써야된다!!!!!!!!!!!
			  
		 8. 제어자
		    - 클래스, 메서드, 변수의 선언부에 사용된다
		    - 접근제어자와 그 외 제어자로 나뉘어 진다
		    - 접근제어자 : public, protected, default, private
		    - 그 외 제어자 : static, final, abstract
		    - 접근제어자와 그 외 제어자가 동시에 있을 때 접근제어자를 가장 왼쪽에 써준다
		    - static(클래스의 친구, 공통적인)
		      : 메서드와 변수, 초기화 블럭에 사용 가능
		      : 클래스 변수
		        -> 모든 인스턴스에서 공통적으로 사용
		        -> 인스턴스를 생성하지 않고 '클래스명.변수명' 으로 호출한다
		        -> 클래스가 메모리에 로드 될 때 함께 로드된다
		      : 클래스 멤버에서는 인스턴스 멤버를 호출 할 수 없다
		    
		    - final(마지막의, 변경할 수 없는)
		      : 변수, 변경할 수 없는 상수가 된다
		      : 메서드, 오버라이드 할 수 없다
		      : 클래스, 부모클래스가 될 수 없다
		    
		    - abstract(추상의, 미완성된)
		      : 메서드, 선언부만 작성하고 구현부{} 작성 되지 않는다
		      : 클래스 , 추상메서드를 가지고 있는 클래스임을 알린다, 클래스 내 미완성된 메서드 하나라도 갖고 있으면 이 클래스가 되는겨
		      
		 9. 접근제어자
		 	- public : 접근제한이 없다.
		 	- protected : 같은 패키지 + 다른 패키지의 자손클래스
		 	- default : 같은 패키지 내에서 호출 가능
		 	- private : 같은 클래스 내에서 호출 가능
		 	
		 	- 멤버변수와 메서드에는 전부 사용 가능
		 	- 클래스에는 public, default만 사용가능
		 	
		 10. 생성자의 접근제어자 
		 	- 인스턴스의 생성을 제한 할 수 있다
		 	- 생성자의 접근제어자를 private으로 변경
		 	  : 객체생성이 불가하다
		 	  : 상속이 불가하다 => 타 클래스의 조상이 될 수 없다
		 	  : 상속할 수 없는 클래스임으로 final을 추가하여 상속할 수 없는 클래임을 알려주는게 좋다,,,,안 써도 된대
		 	- singleTone
		 
		 11. 캡슐화
		    - 접근제어자를 사용하는 이유
		      : 외부로 부터 데이터를 보호하기 위해
		      : 외부엔 불필요한 내부적 사용 부분을 감추기 위해
		      
		 12. 다형성(polymorphism) - 쓰는 이유는 메로리를 아끼기위해! 
		 	- 여러가지 형태를 가질 수 있는 능력
		 	- 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다
		 	- 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다
		 	
		 13. 참조변수의 형변환
		 	- 서로 상속관계에 있는 클래스 간 형변환 가능
		 	- 자식타입 -> 부모타입 (업캐스팅) = 생략 가능
		 	- 부모타입 -> 자식타입 (다운캐스팅) = 생략 불가능
		
		 14. instanceof(형변환을 할 수 있는지 없는지 판단해주는 녀석)
		 	- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
		 	- 연산 결과가 true라면 참조변수가 검사한 타입으로 형변환 가능
		 	- 클래스 메서드는 클래스 변수처럼 참조변수의 타입에 영향을 받는다
		 	- 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다 
		 	
		 	FireCar fc = new FireCar();
		 	(fc instanceof Car)
			  
		15. 매개변수의 다형성
		  	- 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용이 된다
		  	
		16. 여러 개체 배열 Vector(클래스야)
			- 배열을 사용할 경우, 전체크기를 한 번 정하면 변경이 불가하다.
			- 이를 Vector클래스를 이용해 해결 할 수 있다.
			- 동적으로 크기가 관리되는 객체배열
			
			- Vector클래스의 메서드
			  : Vector() => 10개의 객체를 저장할 수 있는 Vector 인스턴스를 생성 //11개 되면 20개 방이 생기고 22개면 30개 생겨서 채워간다.
			  : add(여러가지) => 객체를 추가할 때 사용한다.
			  : get(int index) => index번째 방의 객체를 반환
			  : remove(여러가지) => 객체를 삭제한다.
			  : isEmpty() => Vector에 값이 비어있는지 확인한다.
			  : size() => 객체의 갯수를 반환해준다. 반환타입 int
		
		 17. 추상클래스(abstract class)
		 	- 추상메서드
		 	  : 메서드는 선언부와 구현부로 나뉜다.
		 	  : 선언부만 작성이 되고 구현부는 작성되지 않은 메서드를 추상 메서드라고 한다.
		 	  : 구조
		 	    	abstract 반환타입 메서드명(매개변수); //구현부가 없지, 그래서 앞에 abstract 붙여야 한다.
		 	
		 	- 추상 클래스
		 	  : 추상메서드를 포함하고 있는 클래스
		 	  	abstract class 클래스명{
		 	  	
		 	  	}
		 	  	//상속하는 클래스가 추상이면 상속받는 클래스도 추상클래스
		  
		  18. 인터페이스(interface)
		  	- 일종의 추상클래스 이지만 추상메서드와 상수만을 멤버로 가질 수 있다.
		  	- 인터페이스 작성방법
		  	  interface 인터페이스명{
		  	  	public static final 변수타입 변수명 = 값;//상수다 보니까 나중에 값을 바꿀 수 없지 그래서 final
		  	  	=====> 그래서 (public static final) 변수타입 변수명 = 값; 이라고 되어있으면 돼!!
		  	  	public abstract 반환타입 메서드명(매개변수);
		  	  }
		  	  
				: 모든 멤버변수는 public static final 이어야 한다. => 즉, 생략가능하다.
				: 모든 메서드는 public abstract 이어야 한다. => 즉, 생략가능하다.
		  	- 인터페이스의 상속
		  	  : 인터페이스는 클래스를 상속받을 수 없다.
		  	  : 인터페이스는 인터페이스만 상속받을 수 있다.
		  	  : 인터페이스는 다중 상속이 가능하다!!!! 왜?
		  	  
		  	- 인터페이스의 구현
		  	  : 자체로는 인스턴스를 생성할 수 없다.
		  	  : 자신이 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야한다.
		  	  : 클래스의 확장에는 extends, 인터페이스의 구현에는 implements를 사용한다.
		  	  : ~able(~을 할 수 있는)필요한 메서드를 제공한다는 의미를 강조하기 위해 쓴다. //과거에는 이랬다.
		  	  : IMember => IMemberImpl //현업에서는 이렇게 쓴다. 개발자들 간의 약속
		  	    		그럼 이렇게 쓰는 유형은 뭐가 있을까...???
		  	  
		  	- 인터페이스의 장점
		  	  : 개발시간을 단축시킬 수 있다.
		  	  : 표준화가 가능하다.
		  	  : 서로 관계가 없는 클래스들에게 관계를 맺어줄 수 있다.
		  	  : 독립적인 프로그래밍이 가능하다.
		  	  
		  	- 인터페이스의 이해
		  	  : 클래스를 사용하는 쪽(user)과 제공하는 쪽(provider)이 있다.
		  	  : 메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면된다.
		  	  	A(유저) - I(인터페이스) - B(프로바이더)
		  	
		  	- 인터페이스의 다형성
		  	  : 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다.(다형성)
		  	  : 인터페이스 타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다.
		  
		  19. 내부클래스
		  	- 클래스 내 선언된 클래스이다.
		  	- 서로 쉽게 접근할 수 있고 외부에는 불필요한 클래스를 감춤으로 복잡성을 줄 일 수 있다.
		  	  라고 되어 있지만 개발자 입장에서 복잡하고 접근하기 어렵대....ㅡㅡ;;
		  	- 인스턴스클래스
		  	  : 외부클래스의 인스턴스멤버와 관련된 작업을 수행한다.
		  	
		  	- static 클래스
		  	  : 외부클래스의 클래스멤버와 관련된 작업을 수행한다.
		  	  
		  	- 지역 클래스
		  	  : 선언 영역 내에서만 사용가능하다. 
		  	  
		  	- 익명 클래스
		  	  : 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스이다.
		  	
		  	  
		  	  
		  	  
		 */
		
		
		
		
	}
}
